<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <script src="plotly-latest.min.js"></script>
    <script src="PapaParse-4.1.2/papaparse.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <div id="myDiv1" style="width: 100%; height: 600px;"></div>
    <div class="buttons">
        Filter by GPU number:
        <div class="button" id="all" onclick="continue_proc(filterAll,'');">All</div>
        <div class="button" id="gpu1" onclick="continue_proc(filterByGPU,'1-2');">GPU 1-2</div>
        <div class="button" id="gpu2" onclick="continue_proc(filterByGPU,'3-4');">GPU 3-4</div>
        <div class="button" id="gpu3" onclick="continue_proc(filterByGPU,'5-8');">GPU 5-8</div>
        <div class="button" id="gpu4" onclick="continue_proc(filterByGPU,'9-16');">GPU 9-16</div>
    </div>
    <div class="buttons">
        Filter by provider:
        <div class="button" id="all" onclick="continue_proc(filterAll,'');">All</div>
        <div class="button" id="amazon" onclick="continue_proc(filterProvider,'amazon');">Amazon</div>
        <div class="button" id="gpu2" onclick="continue_proc(filterProvider,'softlayer');">Softlayer</div>
        <div class="button" id="gpu3" onclick="continue_proc(filterProvider,'cirrascale');">Cirrascale</div>
        <div class="button" id="gpu4" onclick="continue_proc(filterProvider,'sakura');">Sakura</div>
    </div>
    <div id="slice" style="width: 100%; height: 600px;"></div>

    <div class="buttons">
        Display for period:
        <div class="button" id="day" onclick="displaySlice(24 );">1 day</div>
        <div class="button" id="week" onclick="displaySlice(24 * 7);">1 week</div>
        <div class="button" id="month" onclick="displaySlice(24 * 30.5);">1 month</div>
        <div class="button" id="6months" onclick="displaySlice(24 * 30.5 * 6);">6 months</div>
        <div class="button" id="12months" onclick="displaySlice(24 * 365);">1 year</div>
    </div>

    <script>
    function loadData(filname) {
        Papa.parse(filname, {
            download: true,
            complete: processStaticData
        });
    }

    var offers_all=[];
    var offers=[];

    function processStaticData(results) {
        console.log("Rows: "+results.data.length);
        //console.log(results);
        //global offers;
        rows = results.data.length
        //rows = 7
        provider = ""
        for (var i=1; i<rows; i++) {
            row = results.data[i];
            //console.log(row);
            //console.log(i+" Provider:"+row[0]+" Offer:"+row[1]+" H.Price:"+row['2'])
            if (provider !=  row[0] && row[0] !="") {
                provider = row[0]
            }
            var offer = {
                provider: provider,
                name: row[1],
                shortname: row[2],
                hourly: row[3],
                weekly: row[4],
                monthly:row[5],
                yearly: row[6],
                cpu_p:  row[7],
                gpu_p:  row[8],
                gpus:   row[9]
            }
            offers_all.push(offer);
        }
        continue_proc(filterAll, "");
    }

    // "Filters" offers: save filtered list in "offers" global variable.
    function filterAll(arg) {
        offers = [];
        for (j=0; j < offers_all.length; j++) {
            offers.push(offers_all[j]);
        }
    }

    // Filters offers: save filtered list in "offers" global variable.
    // Filter out offers with GPUs in range given by group argument with format string "min-miax".
    function filterByGPU(group) {
        offers = [];
        min = 0;
        max = 0;
        splits = group.split("-");
        min = parseInt(splits[0]);
        max = parseInt(splits[1]);
        for (j=0; j < offers_all.length; j++) {
            if (offers_all[j].gpus >= min && offers_all[j].gpus <= max) {
                offers.push(offers_all[j]);
            }
        }
    }

    // Filter by provider
    function filterProvider(prov) {
        offers = [];
        //console.log("Filter " + prov.toLowerCase());
        for (j=0; j < offers_all.length; j++) {
            //console.log(offers_all[j].provider.toLowerCase());
            if (offers_all[j].provider.toLowerCase() == prov.toLowerCase()) {
                offers.push(offers_all[j]);
            }
        }
    }

    // Return array of Cost, Cost/CPU FLops, Cost/GPU FLops for given number of hours (period).
    // Period must be in hours.
    function getQuote(offer, period) {
        var costs = [], costs_cpu=[], costs_gpu=[];
        if (offer.hourly != "" ) {
            for (i=0; i <= period; i++) {
                cost = i * offer.hourly;
                costs.push(cost);
                costs_cpu.push(cost/offer.cpu_p);
                costs_gpu.push(cost/offer.gpu_p);
            }
        } else if (offer.weekly != "" ) {
            for (i=0; i <= period; i++) {
                period_w = Math.ceil(i / (24 * 7));
                cost = period_w * offer.weekly;
                costs.push(cost);
                costs_cpu.push(cost/offer.cpu_p);
                costs_gpu.push(cost/offer.gpu_p);
            }
        } else if (offer.monthly != "" ) {
            for (i=0; i <= period; i++) {
                period_m = Math.ceil(i / (24 * 30.5));
                //console.log("Count "+period+ " hours as " + period_m + " months.")
                cost = period_m * offer.monthly;
                costs.push(cost);
                costs_cpu.push(cost/offer.cpu_p);
                costs_gpu.push(cost/offer.gpu_p);
            }
        } else if (offer.yearly != "" ) {
            for (i=0; i <= period; i++) {
                period_y = Math.ceil(i / (24 * 365));
                cost = period_y * offer.yearly;
                costs.push(cost);
                costs_cpu.push(cost/offer.cpu_p);
                costs_gpu.push(cost/offer.gpu_p);
            }
        }
        return [ costs, costs_cpu, costs_gpu];
    }

    // Convert time in hours to human readable format
    function hoursToHuman(h) {
        var hours_day   = 24;
        var hours_month = 24 * 30.5;
        var hours_year  = 24 * 365;

        var years  = Math.floor(h / hours_year);
        var months = Math.floor((h % hours_year) / hours_month);
        var days   = Math.floor(((h % hours_year) % hours_month) / hours_day);
        var hours  = ((h % hours_year) % hours_month) % hours_day;
        s = "";
        if ( years > 0) {
            s = s + years + " years ";
        }
        if ( months > 0) {
            s = s + months + " months ";
        }
        if ( days > 0) {
            s = s + days + " days ";
        }
        if ( hours > 0) {
            s = s + hours + " hours";
        }
        return s;
    }

    // Return array of dates from 0 to given period of hours
    // with 1 hour step. Second returned variable – array of human readable labels.
    function prepDates(end) {
        var har = [];
        var x = [];
        var text=[];
        start_date = 0;
        for (h = 0; h <= end; h++) {
            x_ = new Date(h * 1000 * 3600);
            x.push(x_);
            har.push(h);
            disp_time = hoursToHuman(h)
            text.push(disp_time);
            //console.log(x_ + "\t" + y_)
        }
        return [har, text];
    }

    var dates =[];
    var quotes=[];

    // Plot all offers costs for given period.
    function plotPeriod(period) {
        var tickvals = [];
        var ticktext = [];
        var traces = [];

        dates = prepDates(period);

        var layout = {
            title: 'Cost per period (USD)',
            hovermode:'closest',
            showticklabels: false,
            xaxis: {
                tickvals: [0,   24*7,     24*30.5,   24*30.5*2,   24*30.5*3,  24*30.5*4,  24*30.5*5,  24*30.5*6,  24*30.5*7,  24*30.5*8,  24*30.5*9,  24*30.5*10,  24*30.5*11,  24*30.5*12 ],
                ticktext: ["0", "1 week", "1 month", "2 months", "3 months", "4 months", "5 months", "6 months", "7 months", "8 months", "9 months", "10 months", "11 months", "12 months"]
            },
            yaxis: {
                tickprefix: "$",
                hoverformat: '.2f',
                exponentformat: "none"
            }
        };

        for (j=0; j < offers.length; j++) {
            quote = getQuote(offers[j], period);
            var trace = {
                mode: 'lines',
                line: {
                    width: 1
                },
                name: offers[j].shortname,
                hoverinfo:"y+name+text",
                x: dates[0],
                text: dates[1],
                y: quote[0] // 0 - Absolute cost
            };
            traces.push(trace);
            quotes.push(quote);
        }
        Plotly.newPlot("myDiv1", traces, layout);
    }

    loadData("cost-performance.csv");

    function continue_proc(filter, arg) {
        filter(arg);
        quotes=[];
        console.log("Have "+ offers.length+" offers.")
        //console.log("Have "+ quotes.length+" quotes.")
        plotPeriod(24*30.5*12);  // Period for top plot
        console.log("Have "+ quotes.length+" quotes.")
        var myPlot = document.getElementById('myDiv1');

        myPlot.on('plotly_click', function(data) {
            //console.log(data);
            var pts = '';
            for(var i=0; i < data.points.length; i++) {
                displaySlice(data.points[i].pointNumber);
            }
        });

        // Display data for 1 month
        displaySlice(24 * 30.5);
    }


    function displaySlice(n) {
        console.log("Clicked "+n+ " X: "+ dates[0][n] + " / " + dates[1][n]);
        var layout_bar = {
            title: "1 TFlops cost per " + dates[1][n],
            barmode: 'group',
            hovermode:'closest',
            xaxis: {
                fixedrange: true
            },
            yaxis: {
                title: 'Cost per CPU 1 TFlops (USD/TFlops)',
                tickprefix: "$",
                hoverformat: '.2f',
                exponentformat: "none",
                separatethousands: true,
                gridcolor: "#d9f0ff",
                linecolor: "#d9f0ff"
            },
            yaxis2: {
                title: 'Cost per GPU 1 TFlops (USD/TFlops)',
                overlaying: 'y',
                side: 'right',
                tickprefix: "$",
                hoverformat: '.2f',
                exponentformat: "none",
                separatethousands: true,
                gridcolor: "#ffe6d6",
                linecolor: "#ffe6d6"
            }
        };
        var y_cpu = [];
        var y_gpu = [];
        var x = [];
        console.log("displaySlice has " + offers.length+" offers.")
        for (j=0; j < offers.length; j++) {
            y_cpu.push(quotes[j][1][n]);
            y_gpu.push(quotes[j][2][n]);
            x.push(offers[j].shortname);
        }

        var trace_cpu = {
            x: x,
            y: y_cpu,
            name: "USD/CPU TFlops",
            offset: -0.4,
            width: 0.35,
            type: "bar"
        };

        var trace_gpu = {
            x: x,
            y: y_gpu,
            name: "USD/GPU TFlops",
            type: "bar",
            offset: 0,
            width: 0.35,
            yaxis: 'y2'
        };

        Plotly.newPlot('slice', [trace_cpu, trace_gpu], layout_bar);
    }

    </script>
</body>
</html>